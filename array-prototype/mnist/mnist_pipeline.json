{
  "weightBuffersAssignment": {
    "buffers": [
      {
        "shape": [
          784,
          100
        ],
        "offset": 0,
        "size": 78400
      },
      {
        "shape": [
          100
        ],
        "offset": 78400,
        "size": 100
      },
      {
        "shape": [
          100,
          100
        ],
        "offset": 78500,
        "size": 10000
      },
      {
        "shape": [
          100
        ],
        "offset": 88500,
        "size": 100
      },
      {
        "shape": [
          100,
          10
        ],
        "offset": 88600,
        "size": 1000
      },
      {
        "shape": [
          10
        ],
        "offset": 89600,
        "size": 10
      }
    ],
    "totalSize": 89610
  },
  "dataBuffersAssignment": {
    "buffers": [
      {
        "shape": [
          1,
          784
        ],
        "offset": 0,
        "size": 784
      },
      {
        "shape": [
          1,
          100
        ],
        "offset": 784,
        "size": 100
      },
      {
        "shape": [
          1,
          100
        ],
        "offset": 884,
        "size": 100
      },
      {
        "shape": [
          1,
          100
        ],
        "offset": 984,
        "size": 100
      },
      {
        "shape": [
          1,
          100
        ],
        "offset": 1084,
        "size": 100
      },
      {
        "shape": [
          1,
          10
        ],
        "offset": 1184,
        "size": 10
      }
    ],
    "totalSize": 1194
  },
  "kernels": [
    {
      "kernelString": "\n#include <metal_stdlib>\nusing namespace metal;\n\n#define WEIGHT_OFFSET 0\n#define INPUT_OFFSET 0\n#define OUTPUT_OFFSET 784\n#define N 784\n#define IN_CH 784\n#define OUT_CH 100\n\nkernel void linear_mul(const device float *weight_buffer[[buffer(0)]],\n                 device float *data_buffer[[buffer(1)]],\n                  uint index[[thread_position_in_grid]])\n{\n  device float *input_data = data_buffer + INPUT_OFFSET;\n  device float *output_data = data_buffer + OUTPUT_OFFSET;\n  const device float *weight_data = weight_buffer + WEIGHT_OFFSET;\n    for (int gid = index; gid < N; gid += 4096) {\n      int out_chid = gid % OUT_CH;\n      int sample_id = gid / OUT_CH;\n      float sum = 0.0;\n      for (int in_chid = 0; in_chid < IN_CH; in_chid++) {\n        sum += input_data[sample_id * IN_CH + in_chid] * weight_data[in_chid * OUT_CH + out_chid];\n      }\n      output_data[gid] = sum;\n    }\n}\n      ",
      "kernelFunctionName": "linear_mul",
      "threadgroupsPerGrid": {
        "width": 8,
        "height": 1,
        "depth": 1
      },
      "threadsPerThreadgroup": {
        "width": 512,
        "height": 1,
        "depth": 1
      }
    },
    {
      "kernelString": "\n#include <metal_stdlib>\nusing namespace metal;\n\n#define BIAS_OFFSET 78400\n#define INPUT_OFFSET 0\n#define OUTPUT_OFFSET 784\n#define N 784\n#define IN_CH 784\n#define OUT_CH 100\n\nkernel void linear_bias(const device float *weight_buffer[[buffer(0)]],\n                 device float *data_buffer[[buffer(1)]],\n                  uint index[[thread_position_in_grid]])\n{\n  //device float *input_data = data_buffer + INPUT_OFFSET;\n  device float *output_data = data_buffer + OUTPUT_OFFSET;\n  const device float *bias_data = weight_buffer + BIAS_OFFSET;\n    for (int gid = index; gid < N; gid += 4096) {\n      int chid = gid % OUT_CH;\n      output_data[gid] += bias_data[chid];\n    }\n}\n      ",
      "kernelFunctionName": "linear_bias",
      "threadgroupsPerGrid": {
        "width": 8,
        "height": 1,
        "depth": 1
      },
      "threadsPerThreadgroup": {
        "width": 512,
        "height": 1,
        "depth": 1
      }
    },
    {
      "kernelString": "\n#include <metal_stdlib>\nusing namespace metal;\n\n#define INPUT_OFFSET 784\n#define OUTPUT_OFFSET 884\n#define N 100\n\nkernel void relu(const device float *weight_buffer[[buffer(0)]],\n                 device float *data_buffer[[buffer(1)]],\n                  uint index[[thread_position_in_grid]])\n{\n  device float *input_data = data_buffer + INPUT_OFFSET;\n  device float *output_data = data_buffer + OUTPUT_OFFSET;\n    for (int gid = index; gid < N; gid += 4096) {\n      float val = input_data[gid];\n      if (val < 0.0) {\n        val = 0.0;\n      }\n      output_data[gid] = val;\n    }\n}\n      ",
      "kernelFunctionName": "relu",
      "threadgroupsPerGrid": {
        "width": 8,
        "height": 1,
        "depth": 1
      },
      "threadsPerThreadgroup": {
        "width": 512,
        "height": 1,
        "depth": 1
      }
    },
    {
      "kernelString": "\n#include <metal_stdlib>\nusing namespace metal;\n\n#define WEIGHT_OFFSET 78500\n#define INPUT_OFFSET 884\n#define OUTPUT_OFFSET 984\n#define N 100\n#define IN_CH 100\n#define OUT_CH 100\n\nkernel void linear_mul(const device float *weight_buffer[[buffer(0)]],\n                 device float *data_buffer[[buffer(1)]],\n                  uint index[[thread_position_in_grid]])\n{\n  device float *input_data = data_buffer + INPUT_OFFSET;\n  device float *output_data = data_buffer + OUTPUT_OFFSET;\n  const device float *weight_data = weight_buffer + WEIGHT_OFFSET;\n    for (int gid = index; gid < N; gid += 4096) {\n      int out_chid = gid % OUT_CH;\n      int sample_id = gid / OUT_CH;\n      float sum = 0.0;\n      for (int in_chid = 0; in_chid < IN_CH; in_chid++) {\n        sum += input_data[sample_id * IN_CH + in_chid] * weight_data[in_chid * OUT_CH + out_chid];\n      }\n      output_data[gid] = sum;\n    }\n}\n      ",
      "kernelFunctionName": "linear_mul",
      "threadgroupsPerGrid": {
        "width": 8,
        "height": 1,
        "depth": 1
      },
      "threadsPerThreadgroup": {
        "width": 512,
        "height": 1,
        "depth": 1
      }
    },
    {
      "kernelString": "\n#include <metal_stdlib>\nusing namespace metal;\n\n#define BIAS_OFFSET 88500\n#define INPUT_OFFSET 884\n#define OUTPUT_OFFSET 984\n#define N 100\n#define IN_CH 100\n#define OUT_CH 100\n\nkernel void linear_bias(const device float *weight_buffer[[buffer(0)]],\n                 device float *data_buffer[[buffer(1)]],\n                  uint index[[thread_position_in_grid]])\n{\n  //device float *input_data = data_buffer + INPUT_OFFSET;\n  device float *output_data = data_buffer + OUTPUT_OFFSET;\n  const device float *bias_data = weight_buffer + BIAS_OFFSET;\n    for (int gid = index; gid < N; gid += 4096) {\n      int chid = gid % OUT_CH;\n      output_data[gid] += bias_data[chid];\n    }\n}\n      ",
      "kernelFunctionName": "linear_bias",
      "threadgroupsPerGrid": {
        "width": 8,
        "height": 1,
        "depth": 1
      },
      "threadsPerThreadgroup": {
        "width": 512,
        "height": 1,
        "depth": 1
      }
    },
    {
      "kernelString": "\n#include <metal_stdlib>\nusing namespace metal;\n\n#define INPUT_OFFSET 984\n#define OUTPUT_OFFSET 1084\n#define N 100\n\nkernel void relu(const device float *weight_buffer[[buffer(0)]],\n                 device float *data_buffer[[buffer(1)]],\n                  uint index[[thread_position_in_grid]])\n{\n  device float *input_data = data_buffer + INPUT_OFFSET;\n  device float *output_data = data_buffer + OUTPUT_OFFSET;\n    for (int gid = index; gid < N; gid += 4096) {\n      float val = input_data[gid];\n      if (val < 0.0) {\n        val = 0.0;\n      }\n      output_data[gid] = val;\n    }\n}\n      ",
      "kernelFunctionName": "relu",
      "threadgroupsPerGrid": {
        "width": 8,
        "height": 1,
        "depth": 1
      },
      "threadsPerThreadgroup": {
        "width": 512,
        "height": 1,
        "depth": 1
      }
    },
    {
      "kernelString": "\n#include <metal_stdlib>\nusing namespace metal;\n\n#define WEIGHT_OFFSET 88600\n#define INPUT_OFFSET 1084\n#define OUTPUT_OFFSET 1184\n#define N 100\n#define IN_CH 100\n#define OUT_CH 10\n\nkernel void linear_mul(const device float *weight_buffer[[buffer(0)]],\n                 device float *data_buffer[[buffer(1)]],\n                  uint index[[thread_position_in_grid]])\n{\n  device float *input_data = data_buffer + INPUT_OFFSET;\n  device float *output_data = data_buffer + OUTPUT_OFFSET;\n  const device float *weight_data = weight_buffer + WEIGHT_OFFSET;\n    for (int gid = index; gid < N; gid += 4096) {\n      int out_chid = gid % OUT_CH;\n      int sample_id = gid / OUT_CH;\n      float sum = 0.0;\n      for (int in_chid = 0; in_chid < IN_CH; in_chid++) {\n        sum += input_data[sample_id * IN_CH + in_chid] * weight_data[in_chid * OUT_CH + out_chid];\n      }\n      output_data[gid] = sum;\n    }\n}\n      ",
      "kernelFunctionName": "linear_mul",
      "threadgroupsPerGrid": {
        "width": 8,
        "height": 1,
        "depth": 1
      },
      "threadsPerThreadgroup": {
        "width": 512,
        "height": 1,
        "depth": 1
      }
    },
    {
      "kernelString": "\n#include <metal_stdlib>\nusing namespace metal;\n\n#define BIAS_OFFSET 89600\n#define INPUT_OFFSET 1084\n#define OUTPUT_OFFSET 1184\n#define N 100\n#define IN_CH 100\n#define OUT_CH 10\n\nkernel void linear_bias(const device float *weight_buffer[[buffer(0)]],\n                 device float *data_buffer[[buffer(1)]],\n                  uint index[[thread_position_in_grid]])\n{\n  //device float *input_data = data_buffer + INPUT_OFFSET;\n  device float *output_data = data_buffer + OUTPUT_OFFSET;\n  const device float *bias_data = weight_buffer + BIAS_OFFSET;\n    for (int gid = index; gid < N; gid += 4096) {\n      int chid = gid % OUT_CH;\n      output_data[gid] += bias_data[chid];\n    }\n}\n      ",
      "kernelFunctionName": "linear_bias",
      "threadgroupsPerGrid": {
        "width": 8,
        "height": 1,
        "depth": 1
      },
      "threadsPerThreadgroup": {
        "width": 512,
        "height": 1,
        "depth": 1
      }
    }
  ],
  "inputs": [
    0
  ],
  "outputs": [
    5
  ]
}